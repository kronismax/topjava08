Index: src/main/java/ru/javaops/masterjava/matrix/MainMatrix.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/ru/javaops/masterjava/matrix/MainMatrix.java	(date 1473202111000)
+++ src/main/java/ru/javaops/masterjava/matrix/MainMatrix.java	(revision )
@@ -20,30 +20,35 @@
 
         double singleThreadSum = 0.;
         double concurrentThreadSum = 0.;
-        for (int i = 0; i < 5; i++) {
-            long start = System.currentTimeMillis();
-            final int[][] matrixC = MatrixUtil.singleThreadMultiply(matrixA, matrixB);
+        final int[][] matrixC = MatrixUtil.singleThreadMultiply(matrixA, matrixB);
-            double duration = (System.currentTimeMillis() - start) / 1000.;
-            out("Single thread time, sec: %.3f", duration);
-            singleThreadSum += duration;
 
-            start = System.currentTimeMillis();
-            final int[][] concurrentMatrixC = MatrixUtil.concurrentMultiply(matrixA, matrixB, executor);
-            duration = (System.currentTimeMillis() - start) / 1000.;
-            out("Concurrent thread time, sec: %.3f", duration);
-            concurrentThreadSum += duration;
+        int[][] concurrentMatrixC = MatrixUtil.concurrentMultiply(matrixA, matrixB, executor);
+        compare(matrixC, concurrentMatrixC);
 
-            if (!MatrixUtil.compare(matrixC, concurrentMatrixC)) {
-                System.err.println("Comparison failed");
-                break;
-            }
-        }
+        concurrentMatrixC = MatrixUtil.concurrentMultiplyCayman(matrixA, matrixB, executor);
+        compare(matrixC, concurrentMatrixC);
+
+        concurrentMatrixC = MatrixUtil.concurrentMultiply2(matrixA, matrixB, executor);
+        compare(matrixC, concurrentMatrixC);
+
+        concurrentMatrixC = MatrixUtil.concurrentMultiply3(matrixA, matrixB, executor);
+        compare(matrixC, concurrentMatrixC);
+
+        concurrentMatrixC = MatrixUtil.concurrentMultiplyAntonManin(matrixA, matrixB, executor);
+        compare(matrixC, concurrentMatrixC);
+
+
+//        concurrentMatrixC = MatrixUtil.concurrentMultiplyMtroot(matrixA, matrixB, executor);
+//        compare(matrixC, concurrentMatrixC);
+
         executor.shutdown();
-        out("\nAverage single thread time, sec: %.3f", singleThreadSum / 5.);
-        out("Average concurrent thread time, sec: %.3f", concurrentThreadSum / 5.);
     }
 
-    private static void out(String format, double ms) {
-        System.out.println(String.format(format, ms));
+    private static void compare(int[][] matrix1, int[][] matrix2) {
+        if (MatrixUtil.compare(matrix1, matrix2)) {
+            System.out.println("Comparison OK");
+        } else {
+            System.err.println("Comparison failed");
+        }
     }
 }
Index: src/main/java/ru/javaops/masterjava/matrix/MatrixUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/ru/javaops/masterjava/matrix/MatrixUtil.java	(date 1473202111000)
+++ src/main/java/ru/javaops/masterjava/matrix/MatrixUtil.java	(revision )
@@ -1,8 +1,7 @@
 package ru.javaops.masterjava.matrix;
 
-import java.util.Random;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
+import java.util.*;
+import java.util.concurrent.*;
 
 /**
  * gkislin
@@ -10,22 +9,213 @@
  */
 public class MatrixUtil {
 
-    // TODO implement parallel multiplication matrixA*matrixB
     public static int[][] concurrentMultiply(int[][] matrixA, int[][] matrixB, ExecutorService executor) throws InterruptedException, ExecutionException {
+        final int matrixSize = matrixA.length;
+
+        class ColumnMultipleResult {
+            private final int col;
+            private final int[] columnC;
+
+            private ColumnMultipleResult(int col, int[] columnC) {
+                this.col = col;
+                this.columnC = columnC;
+            }
+        }
+
+        final CompletionService<ColumnMultipleResult> completionService = new ExecutorCompletionService<>(executor);
+
+        for (int j = 0; j < matrixSize; j++) {
+            final int col = j;
+            final int[] columnB = new int[matrixSize];
+            for (int k = 0; k < matrixSize; k++) {
+                columnB[k] = matrixB[k][col];
+            }
+            completionService.submit(() -> {
+                final int[] columnC = new int[matrixSize];
+
+                for (int row = 0; row < matrixSize; row++) {
+                    final int[] rowA = matrixA[row];
+                    int sum = 0;
+                    for (int k = 0; k < matrixSize; k++) {
+                        sum += rowA[k] * columnB[k];
+                    }
+                    columnC[row] = sum;
+                }
+                return new ColumnMultipleResult(col, columnC);
+            });
+        }
+
+        final int[][] matrixC = new int[matrixSize][matrixSize];
+
+        for (int i = 0; i < matrixSize; i++) {
+            ColumnMultipleResult res = completionService.take().get();
+            for (int k = 0; k < matrixSize; k++) {
+                matrixC[k][res.col] = res.columnC[k];
+            }
+        }
+        return matrixC;
+    }
+
+    public static int[][] concurrentMultiply2(int[][] matrixA, int[][] matrixB, ExecutorService executor) throws InterruptedException, ExecutionException {
+        final int matrixSize = matrixA.length;
+        final int[][] matrixC = new int[matrixSize][matrixSize];
+        List<Callable<Void>> tasks = new ArrayList<>(matrixSize);
+
+        for (int j = 0; j < matrixSize; j++) {
+            final int col = j;
+            final int[] columnB = new int[matrixSize];
+            for (int k = 0; k < matrixSize; k++) {
+                columnB[k] = matrixB[k][col];
+            }
+            tasks.add(() -> {
+                for (int row = 0; row < matrixSize; row++) {
+                    final int[] rowA = matrixA[row];
+                    int sum = 0;
+                    for (int k = 0; k < matrixSize; k++) {
+                        sum += rowA[k] * columnB[k];
+                    }
+                    matrixC[row][col] = sum;
+                }
-        return null;
+                return null;
+            });
-    }
+        }
+        executor.invokeAll(tasks);
+        return matrixC;
+    }
 
-    public static int[][] singleThreadMultiply(int[][] matrixA, int[][] matrixB) {
+    public static int[][] concurrentMultiply3(int[][] matrixA, int[][] matrixB, ExecutorService executor) throws InterruptedException, ExecutionException {
         final int matrixSize = matrixA.length;
+        final int[][] matrixC = new int[matrixSize][];
+
+        final int[][] matrixBT = new int[matrixSize][matrixSize];
+        for (int i = 0; i < matrixSize; i++) {
+            for (int j = 0; j < matrixSize; j++) {
+                matrixBT[i][j] = matrixB[j][i];
+            }
+        }
+
+        List<Callable<Void>> tasks = new ArrayList<>(matrixSize);
+        for (int j = 0; j < matrixSize; j++) {
+            final int row = j;
+            tasks.add(() -> {
+                final int[] rowC = new int[matrixSize];
+                for (int col = 0; col < matrixSize; col++) {
+                    final int[] rowA = matrixA[row];
+                    final int[] columnB = matrixBT[col];
+                    int sum = 0;
+                    for (int k = 0; k < matrixSize; k++) {
+                        sum += rowA[k] * columnB[k];
+                    }
+                    rowC[col] = sum;
+                }
+                matrixC[row] = rowC;
+                return null;
+            });
+        }
+        executor.invokeAll(tasks);
+        return matrixC;
+    }
+
+    public static int[][] concurrentMultiplyCayman(int[][] matrixA, int[][] matrixB, ExecutorService executor) throws InterruptedException, ExecutionException {
+        final int matrixSize = matrixA.length;
+        final int[][] matrixResult = new int[matrixSize][matrixSize];
+        final int threadCount = Runtime.getRuntime().availableProcessors();
+        final int maxIndex = matrixSize * matrixSize;
+        final int cellsInThread = maxIndex / threadCount;
+        final int[][] matrixBFinal = new int[matrixSize][matrixSize];
+
+        for (int i = 0; i < matrixSize; i++) {
+            for (int j = 0; j < matrixSize; j++) {
+                matrixBFinal[i][j] = matrixB[j][i];
+            }
+        }
+
+        Set<Callable<Boolean>> threads = new HashSet<>();
+        int fromIndex = 0;
+        for (int i = 1; i <= threadCount; i++) {
+            final int toIndex = i == threadCount ? maxIndex : fromIndex + cellsInThread;
+            final int firstIndexFinal = fromIndex;
+            threads.add(() -> {
+                for (int j = firstIndexFinal; j < toIndex; j++) {
+                    final int row = j / matrixSize;
+                    final int col = j % matrixSize;
+
+                    int sum = 0;
+                    for (int k = 0; k < matrixSize; k++) {
+                        sum += matrixA[row][k] * matrixBFinal[col][k];
+                    }
+                    matrixResult[row][col] = sum;
+                }
+                return true;
+            });
+            fromIndex = toIndex;
+        }
+        executor.invokeAll(threads);
+        return matrixResult;
+    }
+
+    public static int[][] concurrentMultiplyAntonManin(final int[][] matrixA, final int[][] matrixB, ExecutorService executor) throws InterruptedException, ExecutionException {
+        final int matrixSize = matrixA.length;
         final int[][] matrixC = new int[matrixSize][matrixSize];
+        final int[][] matrixBT = new int[matrixSize][matrixSize];
+        List<Future<Boolean>> futures = new LinkedList<Future<Boolean>>();
+        CompletionService<Boolean> completionService = new ExecutorCompletionService<Boolean>(executor);
 
-        for (int i = 0; i < matrixSize; i++) {
+        for (int i = 0; i < matrixSize; i++ ) {
             for (int j = 0; j < matrixSize; j++) {
+                matrixBT[j][i] = matrixB[i][j];
+            }
+        }
+
+        for (int i = 0; i < matrixSize; i++) {
+            for (int j = 0; j < matrixSize; j++) {
+                final int row = i;
+                final int column = j;
+
+                futures.add(completionService.submit(new Callable<Boolean>() {
+                    @Override
+                    public Boolean call() {
-                int sum = 0;
+                        int sum = 0;
+
-                for (int k = 0; k < matrixSize; k++) {
+                        for (int k = 0; k < matrixSize; k++) {
-                    sum += matrixA[i][k] * matrixB[k][j];
+                            sum += matrixA[row][k] * matrixBT[column][k];
-                }
+                        }
-                matrixC[i][j] = sum;
+
+                        matrixC[row][column] = sum;
+
+                        return true;
+                    }
+                }));
+            }
+        }
+
+        while (!futures.isEmpty()) {
+            Future<Boolean> completed = completionService.poll();
+            if (completed != null) {
+                futures.remove(completed);
+            }
+        }
+
+        return matrixC;
+    }
+
+    public static int[][] singleThreadMultiply(int[][] matrixA, int[][] matrixB) {
+        final int matrixSize = matrixA.length;
+        final int[][] matrixC = new int[matrixSize][matrixSize];
+
+        for (int col = 0; col < matrixSize; col++) {
+            final int[] columnB = new int[matrixSize];
+            for (int k = 0; k < matrixSize; k++) {
+                columnB[k] = matrixB[k][col];
+            }
+
+            for (int row = 0; row < matrixSize; row++) {
+                int sum = 0;
+                final int[] rowA = matrixA[row];
+                for (int k = 0; k < matrixSize; k++) {
+                    sum += rowA[k] * columnB[k];
+                }
+                matrixC[row][col] = sum;
             }
         }
         return matrixC;
Index: pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- pom.xml	(date 1473202111000)
+++ pom.xml	(revision )
@@ -15,6 +15,7 @@
         <java.version>1.8</java.version>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <jmh.version>1.13</jmh.version>
     </properties>
 
     <build>
@@ -30,10 +31,61 @@
                     <target>${java.version}</target>
                 </configuration>
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-shade-plugin</artifactId>
+                <version>2.2</version>
+                <executions>
+                    <execution>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>shade</goal>
+                        </goals>
+                        <configuration>
+                            <finalName>benchmarks</finalName>
+                            <transformers>
+                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
+                                    <mainClass>org.openjdk.jmh.Main</mainClass>
+                                </transformer>
+                            </transformers>
+                            <filters>
+                                <filter>
+                                    <!--
+                                        Shading signed JARs will fail without this.
+                                        http://stackoverflow.com/questions/999489/invalid-signature-file-when-attempting-to-run-a-jar
+                                    -->
+                                    <artifact>*:*</artifact>
+                                    <excludes>
+                                        <exclude>META-INF/*.SF</exclude>
+                                        <exclude>META-INF/*.DSA</exclude>
+                                        <exclude>META-INF/*.RSA</exclude>
+                                    </excludes>
+                                </filter>
+                            </filters>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
         </plugins>
     </build>
 
     <dependencies>
+        <dependency>
+            <groupId>org.openjdk.jmh</groupId>
+            <artifactId>jmh-core</artifactId>
+            <version>${jmh.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.openjdk.jmh</groupId>
+            <artifactId>jmh-generator-annprocess</artifactId>
+            <version>${jmh.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.googlecode.matrix-toolkits-java</groupId>
+            <artifactId>mtj</artifactId>
+            <version>1.0.4</version>
+        </dependency>
     </dependencies>
 
     <profiles>
Index: src/main/java/ru/javaops/masterjava/MatrixBenchmark.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/ru/javaops/masterjava/MatrixBenchmark.java	(revision )
+++ src/main/java/ru/javaops/masterjava/MatrixBenchmark.java	(revision )
@@ -0,0 +1,85 @@
+package ru.javaops.masterjava;
+
+import org.openjdk.jmh.annotations.*;
+import org.openjdk.jmh.runner.Runner;
+import org.openjdk.jmh.runner.RunnerException;
+import org.openjdk.jmh.runner.options.Options;
+import org.openjdk.jmh.runner.options.OptionsBuilder;
+import org.openjdk.jmh.runner.options.TimeValue;
+import ru.javaops.masterjava.matrix.MatrixUtil;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+@Warmup(iterations = 10)
+@Measurement(iterations = 10)
+@BenchmarkMode({Mode.SingleShotTime})
+@OutputTimeUnit(TimeUnit.MILLISECONDS)
+@State(Scope.Benchmark)
+@Threads(1)
+@Fork(1)
+@Timeout(time = 5, timeUnit = TimeUnit.MINUTES)
+public class MatrixBenchmark {
+
+    // Matrix size
+    @Param({/*"100",*/ "1000"})
+    private int matrixSize;
+
+    private static final int THREAD_NUMBER = 10;
+    private final static ExecutorService executor = Executors.newFixedThreadPool(THREAD_NUMBER);
+
+    private static int[][] matrixA;
+    private static int[][] matrixB;
+
+    public static void main(String[] args) throws RunnerException {
+        Options options = new OptionsBuilder()
+                .include(MatrixBenchmark.class.getSimpleName())
+                .threads(1)
+                .forks(1)
+                .timeout(TimeValue.minutes(5))
+                .build();
+        new Runner(options).run();
+    }
+
+    @Setup
+    public void setUp() {
+        matrixA = MatrixUtil.create(matrixSize);
+        matrixB = MatrixUtil.create(matrixSize);
+    }
+
+    //    @Benchmark
+    public int[][] singleThreadMultiply() throws Exception {
+        return MatrixUtil.singleThreadMultiply(matrixA, matrixB);
+    }
+
+    @Benchmark
+    public int[][] concurrentMultiply() throws Exception {
+        return MatrixUtil.concurrentMultiply(matrixA, matrixB, executor);
+    }
+
+    @Benchmark
+    public int[][] concurrentMultiply2() throws Exception {
+        return MatrixUtil.concurrentMultiply2(matrixA, matrixB, executor);
+    }
+
+    @Benchmark
+    public int[][] concurrentMultiplyCayman() throws Exception {
+        return MatrixUtil.concurrentMultiplyCayman(matrixA, matrixB, executor);
+    }
+
+    @Benchmark
+    public int[][] concurrentMultiply3() throws Exception {
+        return MatrixUtil.concurrentMultiply3(matrixA, matrixB, executor);
+    }
+
+    @Benchmark
+    public int[][] concurrentMultiplyAntonManin() throws Exception {
+        return MatrixUtil.concurrentMultiplyAntonManin(matrixA, matrixB, executor);
+    }
+
+    @TearDown
+    public void tearDown() {
+        executor.shutdown();
+    }
+}
\ No newline at end of file
Index: src/main/java/ru/javaops/masterjava/service/MailService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/ru/javaops/masterjava/service/MailService.java	(date 1473202111000)
+++ src/main/java/ru/javaops/masterjava/service/MailService.java	(revision )
@@ -19,7 +19,7 @@
         final CompletionService<MailResult> completionService = new ExecutorCompletionService<>(mailExecutor);
 
         List<Future<MailResult>> futures = emails.stream()
-                .map(email -> mailExecutor.submit(() -> sendToUser(template, email)))
+                .map(email -> completionService.submit(() -> sendToUser(template, email)))
                 .collect(Collectors.toList());
 
         return new Callable<GroupResult>() {
